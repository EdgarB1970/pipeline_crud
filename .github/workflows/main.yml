name: CI/CD Pipelineon:  push:    branches:      - master      - develop  pull_request:    branches:      - master      - developenv:  # Variables compartidas por todos los jobs  APP_NAME: ${{ github.event.repository.name }}  APP_VERSION: ${{ github.sha }}  CI_REGISTRY_IMAGE: docker.pkg.github.com/${{ github.repository }}jobs:  # Job de validación (Maven)  validate:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v4      - name: Set up JDK 17        uses: actions/setup-java@v4        with:          java-version: '17'          distribution: 'temurin'          cache: maven      - name: Validate code        run: mvn --batch-mode validate compile  # Job de pruebas unitarias  test-unit:    runs-on: ubuntu-latest    needs: [validate]    steps:      - uses: actions/checkout@v4      - name: Set up JDK 17        uses: actions/setup-java@v4        with:          java-version: '17'          distribution: 'temurin'          cache: maven      - name: Run unit tests        run: mvn --batch-mode test -Dtest="*Unit*"      - name: Upload test results        uses: actions/upload-artifact@v4        if: always()        with:          name: unit-test-results          path: target/surefire-reports  # Job de pruebas de integración  test-integration:    runs-on: ubuntu-latest    needs: [test-unit]    services:      redis:        image: redis:7-alpine      kafka:        image: confluentinc/cp-kafka:latest      cassandra:        image: cassandra:4.0    steps:      - uses: actions/checkout@v4      - name: Set up JDK 17        uses: actions/setup-java@v4        with:          java-version: '17'          distribution: 'temurin'          cache: maven      - name: Run integration tests        run: mvn --batch-mode verify -Dtest="*Integration*"      - name: Upload integration test results        uses: actions/upload-artifact@v4        if: always()        with:          name: integration-test-results          path: target/failsafe-reports  # Job de construcción de la aplicación y la imagen Docker  build:    runs-on: ubuntu-latest    needs: [test-integration]    if: github.ref == 'refs/heads/master'    permissions:      contents: read      packages: write    steps:      - uses: actions/checkout@v4      - name: Set up JDK 17        uses: actions/setup-java@v4        with:          java-version: '17'          distribution: 'temurin'          cache: maven      - name: Configure Docker        uses: docker/login-action@v3        with:          registry: ghcr.io          username: ${{ github.actor }}          password: ${{ secrets.GITHUB_TOKEN }}      - name: Set up image name        run: echo "IMAGE_NAME=${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV      - name: Build and push Docker image        run: |          mvn --batch-mode compile jib:build \            -Djib.to.image=ghcr.io/${{ env.IMAGE_NAME }}:${{ github.sha }} \            -Djib.to.auth.username=${{ github.actor }} \            -Djib.to.auth.password=${{ secrets.GITHUB_TOKEN }}  # Job de escaneo de seguridad con Trivy  security-scan:    runs-on: ubuntu-latest    needs: [build]    steps:      - uses: actions/checkout@v4      - name: Set up image name        run: echo "IMAGE_NAME=${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV      - name: Docker login to GHCR        uses: docker/login-action@v3        with:          registry: ghcr.io          username: ${{ github.actor }}          password: ${{ secrets.GITHUB_TOKEN }}      - name: Pull Docker image        run: docker pull ghcr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}      - name: Scan Docker image with Trivy        uses: aquasecurity/trivy-action@0.22.0        with:          image-ref: ghcr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}          format: 'table'          output: 'trivy-report.txt'          ignore-unfixed: true          vuln-type: 'os,library'          severity: 'HIGH,CRITICAL'      - name: Upload Security Report        uses: actions/upload-artifact@v4        if: always()        with:          name: trivy-security-report          path: trivy-report.txt  # Job de despliegue simplificado  deploy-dev:    runs-on: ubuntu-latest    needs: [build, security-scan]    if: github.ref == 'refs/heads/master'    steps:      - uses: actions/checkout@v4      - name: Set up image name        run: echo "IMAGE_NAME=${GITHUB_REPOSITORY,,}" >> $GITHUB_ENV      - name: Start Minikube        uses: medyagh/setup-minikube@v0.0.16        with:          minikube-version: 1.32.0          kubernetes-version: v1.28.0          driver: docker      - name: Create Kube Namespace and App Name Variables        run: |          SAFE_REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')          SAFE_REF_NAME=$(echo "${{ github.ref_name }}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')          echo "KUBE_NAMESPACE=$SAFE_REPO_NAME-$SAFE_REF_NAME" >> $GITHUB_ENV          echo "KUBE_APP_NAME=$SAFE_REPO_NAME" >> $GITHUB_ENV      # CORRECCIÓN: Crea el namespace en su propio paso      - name: Create Kube Namespace        run: kubectl create namespace ${{ env.KUBE_NAMESPACE }}      - name: Create Secrets for App        run: |          kubectl create secret generic spring-boot-secrets -n ${{ env.KUBE_NAMESPACE }} \            --from-literal=CASSANDRA_USER=${{ secrets.CASSANDRA_USER }} \            --from-literal=CASSANDRA_PASSWORD=${{ secrets.CASSANDRA_PASSWORD }} \            --from-literal=KAFKA_SASL_USERNAME=${{ secrets.KAFKA_SASL_USERNAME }} \            --from-literal=KAFKA_SASL_PASSWORD=${{ secrets.KAFKA_SASL_PASSWORD }}      - name: Deploy to Minikube        run: |          export IMAGE_NAME=ghcr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}          export KUBE_APP_NAME=${{ env.KUBE_APP_NAME }}          export KUBE_NAMESPACE=${{ env.KUBE_NAMESPACE }}                    envsubst < k8s/app-deployment.yml | kubectl apply -n $KUBE_NAMESPACE -f -          envsubst < k8s/app-service.yml | kubectl apply -n $KUBE_NAMESPACE -f -                    kubectl rollout status deployment/$KUBE_APP_NAME -n $KUBE_NAMESPACE --timeout=300s      - name: Verify deployment        run: |          kubectl get pods -n ${{ env.KUBE_NAMESPACE }}          kubectl get services -n ${{ env.KUBE_NAMESPACE }}      - name: Health check        run: |          kubectl wait --for=condition=ready pod -l app=${{ env.KUBE_APP_NAME }} -n ${{ env.KUBE_NAMESPACE }} --timeout=300s          echo "Deployment successful!"