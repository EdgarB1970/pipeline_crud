name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main
      - develop

env:
  # Variables compartidas por todos los jobs
  APP_NAME: ${{ github.event.repository.name }}
  APP_VERSION: ${{ github.sha }}
  KUBE_NAMESPACE: ${{ github.event.repository.name }}-${{ github.ref_name }}
  CI_REGISTRY_IMAGE: docker.pkg.github.com/${{ github.repository }}

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      - name: Validate
        run: mvn --batch-mode validate compile

  test-unit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      - name: Run Unit Tests
        run: mvn --batch-mode test -Dtest="*Unit*"

  test-integration:
    runs-on: ubuntu-latest
    services:
      redis:
        image: redis:7-alpine
      kafka:
        image: confluentinc/cp-kafka:latest
      cassandra:
        image: cassandra:4.0
    env:
      SPRING_DATA_REDIS_HOST: redis
      SPRING_DATA_REDIS_PORT: 6379
      SPRING_KAFKA_BOOTSTRAP_SERVERS: kafka:9092
      SPRING_DATA_CASSANDRA_CONTACT_POINTS: cassandra
      SPRING_DATA_CASSANDRA_PORT: 9042
      SPRING_DATA_CASSANDRA_KEYSPACE_NAME: myapp_test
    steps:
      - uses: actions/checkout@v3
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      - name: Run Integration Tests
        run: mvn --batch-mode verify -Dtest="*Integration*" -DfailIfNoTests=false

  security-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      - name: Run Dependency Check
        run: mvn --batch-mode org.owasp:dependency-check-maven:check
      - name: Upload Security Report
        uses: actions/upload-artifact@v3
        with:
          name: security-report
          path: target/dependency-check-report.html
    allow-failure: true

  build:
    runs-on: ubuntu-latest
    needs: [test-unit, test-integration]
    steps:
      - uses: actions/checkout@v3
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      - name: Package JAR
        run: mvn --batch-mode clean package -DskipTests
      - name: Upload JAR
        uses: actions/upload-artifact@v3
        with:
          name: jar-file
          path: target/*.jar

  docker-build:
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - uses: actions/checkout@v3
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      - name: Login to GitHub Packages
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Build and Push Docker Image
        run: |
          mvn --batch-mode jib:build -Djib.to.image=ghcr.io/${{ github.repository }}:${{ github.sha }}
          mvn --batch-mode jib:build -Djib.to.image=ghcr.io/${{ github.repository }}:latest

  deploy-dev:
    runs-on: ubuntu-latest
    needs: [docker-build]
    environment:
      name: development
      url: http://dev-${{ github.event.repository.name }}.k8s.local
    steps:
      - uses: actions/checkout@v3
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        id: install
      - name: Configure Kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl config use-context ${{ secrets.KUBE_CONTEXT }}
      - name: Create Namespace
        run: kubectl create namespace ${{ env.KUBE_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
      - name: Deploy Infrastructure
        run: |
          envsubst < k8s/configmap.yml | kubectl apply -n ${{ env.KUBE_NAMESPACE }} -f -
          envsubst < k8s/prometheus-configmap.yml | kubectl apply -n ${{ env.KUBE_NAMESPACE }} -f -
          envsubst < k8s/secret.yml | kubectl apply -n ${{ env.KUBE_NAMESPACE }} -f -
          kubectl apply -f k8s/infra/ -n ${{ env.KUBE_NAMESPACE }}
      - name: Wait for Infrastructure
        run: |
          kubectl wait --for=condition=ready pod -l app=redis -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=kafka -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=cassandra -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=prometheus -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=grafana -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
      - name: Deploy Application
        run: |
          envsubst < k8s/app-deployment.yml | kubectl apply -n ${{ env.KUBE_NAMESPACE }} -f -
          kubectl rollout status "deployment/${{ env.APP_NAME }}" -n ${{ env.KUBE_NAMESPACE }} --timeout=600s
    env:
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      CASSANDRA_USER: ${{ secrets.CASSANDRA_USER }}
      CASSANDRA_PASSWORD: ${{ secrets.CASSANDRA_PASSWORD }}
      KAFKA_SASL_USERNAME: ${{ secrets.KAFKA_SASL_USERNAME }}
      KAFKA_SASL_PASSWORD: ${{ secrets.KAFKA_SASL_PASSWORD }}
      API_KEY: ${{ secrets.API_KEY }}
    if: github.ref == 'refs/heads/develop'

  health-check:
    runs-on: ubuntu-latest
    needs: [deploy-dev]
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        id: install
      - name: Configure Kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl config use-context ${{ secrets.KUBE_CONTEXT }}
      - name: Health Check
        run: |
          APP_POD=$(kubectl get pods -n ${{ env.KUBE_NAMESPACE }} -l "app=${{ env.APP_NAME }}" -o jsonpath='{.items[0].metadata.name}')
          kubectl exec -n ${{ env.KUBE_NAMESPACE }} "$APP_POD" -- curl -f http://localhost:8081/actuator/health

  deploy-staging:
    runs-on: ubuntu-latest
    needs: [docker-build]
    environment:
      name: staging
      url: http://staging-${{ github.event.repository.name }}.k8s.local
    steps:
      - uses: actions/checkout@v3
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        id: install
      - name: Configure Kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl config use-context ${{ secrets.KUBE_CONTEXT }}
      - name: Deploy Infrastructure
        run: |
          envsubst < k8s/configmap.yml | kubectl apply -n ${{ env.KUBE_NAMESPACE }} -f -
          envsubst < k8s/prometheus-configmap.yml | kubectl apply -n ${{ env.KUBE_NAMESPACE }} -f -
          envsubst < k8s/secret.yml | kubectl apply -n ${{ env.KUBE_NAMESPACE }} -f -
          kubectl apply -f k8s/infra/ -n ${{ env.KUBE_NAMESPACE }}
      - name: Wait for Infrastructure
        run: |
          kubectl wait --for=condition=ready pod -l app=redis -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=kafka -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=cassandra -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=prometheus -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=grafana -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
      - name: Deploy Application
        run: |
          envsubst < k8s/app-deployment.yml | kubectl apply -n ${{ env.KUBE_NAMESPACE }} -f -
          kubectl rollout status "deployment/${{ env.APP_NAME }}" -n ${{ env.KUBE_NAMESPACE }} --timeout=600s
    env:
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      CASSANDRA_USER: ${{ secrets.CASSANDRA_USER }}
      CASSANDRA_PASSWORD: ${{ secrets.CASSANDRA_PASSWORD }}
      KAFKA_SASL_USERNAME: ${{ secrets.KAFKA_SASL_USERNAME }}
      KAFKA_SASL_PASSWORD: ${{ secrets.KAFKA_SASL_PASSWORD }}
      API_KEY: ${{ secrets.API_KEY }}
    if: github.ref == 'refs/heads/main'

  deploy-prod:
    runs-on: ubuntu-latest
    needs: [docker-build]
    environment:
      name: production
      url: http://${{ github.event.repository.name }}.k8s.local
    steps:
      - uses: actions/checkout@v3
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        id: install
      - name: Configure Kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl config use-context ${{ secrets.KUBE_CONTEXT }}
      - name: Deploy Infrastructure
        run: |
          envsubst < k8s/configmap.yml | kubectl apply -n ${{ env.KUBE_NAMESPACE }} -f -
          envsubst < k8s/prometheus-configmap.yml | kubectl apply -n ${{ env.KUBE_NAMESPACE }} -f -
          envsubst < k8s/secret.yml | kubectl apply -n ${{ env.KUBE_NAMESPACE }} -f -
          kubectl apply -f k8s/infra/ -n ${{ env.KUBE_NAMESPACE }}
      - name: Wait for Infrastructure
        run: |
          kubectl wait --for=condition=ready pod -l app=redis -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=kafka -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=cassandra -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=prometheus -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app=grafana -n ${{ env.KUBE_NAMESPACE }} --timeout=300s
      - name: Deploy Application
        run: |
          envsubst < k8s/app-deployment.yml | kubectl apply -n ${{ env.KUBE_NAMESPACE }} -f -
          kubectl rollout status "deployment/${{ env.APP_NAME }}" -n ${{ env.KUBE_NAMESPACE }} --timeout=600s
    env:
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      CASSANDRA_USER: ${{ secrets.CASSANDRA_USER }}
      CASSANDRA_PASSWORD: ${{ secrets.CASSANDRA_PASSWORD }}
      KAFKA_SASL_USERNAME: ${{ secrets.KAFKA_SASL_USERNAME }}
      KAFKA_SASL_PASSWORD: ${{ secrets.KAFKA_SASL_PASSWORD }}
      API_KEY: ${{ secrets.API_KEY }}
    if: github.ref == 'refs/heads/main'